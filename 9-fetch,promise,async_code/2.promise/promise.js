// ===================================================== Aсинхронный код =====================================================
// 1,3,2 так как ситивой запрос (дфннфе от backend) будут использоватся 2 последний
// Aсинхронный код - это код, которому требуется время на выполнение
// JS фактически не дожедается выполнения асихронного фрагмента кода.

// ------------------------------------------------------- setTimeout -------------------------------------------------------

// Явное демонстрация выполнения фрагментов кода с задержкой
// aсинхронный
setTimeout(() =>{
    console.log(1);
}, 2000) // 2000 милисекунд = 2 секунды wartezeit

// синхронный -> без задержки
console.log(4);

// Порядок выполнение кода 
// 4
// 1

// -----------------------------------------------
// Другой пример - Этот пример наглядно демонстрирует, что порядок выполнения code1 и code2 
// будет определятся рандомным образом

setTimeout(() =>{
    console.log('code 1');
}, Math.random() * 1000)

setTimeout(() =>{
    console.log('code 2');
}, Math.random() * 1000) // задежка от место полежения сервира и клиента

// Порядок выполнение кода 
// 4
// code 1
// code 2
// 1

// после второго разa время формируется рандомом (нет гарантии что будет всегда одинаково)

// 4
// code 2
// code 1
// 1

// ---------------------------------------------------------
// Вложение обезательно чтобы порядок был правельным 1,2,3
// Гарантировать что выполнение будет всегда одинаковым
// Блогодоря вложенности теперь мы гарантируем порядок выполнения команд
setTimeout(() =>{
    console.log('code 3');
    let a = [1,2,3,4]

    setTimeout(() =>{
        console.log(a, 'code 4');
        console.log('code 5');
    }, Math.random() * 1000)

}, Math.random() * 1000)

// Порядок выполнение кода 
// 4
// code 3
// code 4
// 1 


//  ------------------------------------------------------- Promise ----------------------------------------------------
// Обект Promise - это обвертка для асинхроного кода, который позволяет
// гарантировать порядок выполнения процессов, МИНУЯ ВЛОЖЕНОСТЬ
//                                Promise
//                                  |
//                                  Pending (ожидания)
//                               /      \
//                              /        \
// resolve(ответ есть от сервера)         reject(ответ нет от сервера)


// В Promise помещается только асинхронная часть кода!
// В противном случае в Promise никокого смысла нет

let promise = new Promise((resolve, reject) => {
    setTimeout(() =>{
        console.log('generate array (code 1.0)');
        let a = [1,2,3,4]
        resolve(a)
        // reject()
    }, Math.random() * 1000)
})
// console.log(promise);


// ------------------------------------------------------------ promise.then() ------------------------------------------------------------
// Метод - then дожидается пока Promise перейдёт в состояние resolve 
// и далее выполнит свое тело колбека

// у Promise может быть реализовано цепочка вызова then.
// Методы then могут передавать следощему методу then через return
promise
    .then((a) => {
        console.log(a, 'code 2.0'); //при обновление строницы порядок не меняется и сode 2.0 будет в конце(по очерёдности)
        a.push(5)
        return a
    })
    .then((a) => {
        console.log(a, 'change array (code 3.0)'); 
    })



// ------------------------------------------------------------------------
// Реализация двух запросов (как в премере выше) без вложености
let promise1 = new Promise((resolve, reject) => {
    setTimeout(() =>{
        console.log('generate (code)');
        let a = [1,2,3,4]
        resolve(a)
    }, Math.random() * 100)
})
    .then(a => {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                console.log(a, 'code');
                a.push(5)
                resolve(a)
            }, Math.random() * 100)
        })
    })
    .then((a) => {
        console.log(a, 'finish (code)');
    })


// -------------------------------------------------------------- catch() / finally() ------------------------------------------------------------
// catch() - catch() - метод промиса, который будет выполнять свое тело после того, 
// как промис получит статус REJECT.
// Однако при таком сценарии тело метода then

// finally() - такойже метод как then() и catch(), но будет выполнятся вне 
// зависимости от того, в кокое состояние упал Promise 
// (resolve или reject)

// (пример / окно блокируешие по середине) сервис не доступен времена

new Promise((resolve, reject) => {
    setTimeout(() =>{
        console.log('code 11');
        reject('rejected!')
        // resolve()
    }, Math.random() * 100)
})
    .then(() => {
        console.log('code 22');
        // render(data);
    })

    .catch((e) => {
        console.log(e);
        // errorRender();
    })

// ================================================================== Practice =================================================================
// Задание 1. 
// Задан фрагмент асинхронного кода, который спустя 0.4 секунд
// формирует массив. 
// Необходимо реализовать процесс, который дождется выполнения 
// асихнронного кода и выведет сумму всех элементов массива
// Примечание: расчет суммы внутри задержки делать нельзя 

let promise2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        let array = [1,2,3,4,5];
        resolve(array);
    }, 400);
})
    promise2.then(array => {
        let sum = array.reduce((acc, curr) => acc + curr, 0);
        console.log('Сумма всех элементов массива:', sum);
    })
    promise2.catch(error => {
        console.error('Ошибка:', error);
    });



// Задание 2. 
// Задан фрагмент асинхронного кода, который спустя 0.5 секунд
// рандомным образом создает переменную number. Релизуйте процесс, который
// в случае если число окажется нечетным - вернет текст ошибки 'error'. 
// Если число окажется четным - тогда значение квадрата этого рандомного числа
// Примечание: Логи внутри задержки делать нельзя

let promise3 = new Promise((resolve, reject) => {
    setTimeout(() => {
        let number = Math.round(Math.random() * 10)
        if (number % 2 === 0){
            resolve(number)
        } else {
            reject('error')
        }
    }, 500); 
})
    .then(number => {
        console.log(number ** 2);
    })
    .catch(e => {
        console.log('Ошибка:', e);
    })
    .finally(() => {
        console.log('finally');
    })





